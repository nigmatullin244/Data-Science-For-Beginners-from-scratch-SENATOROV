"""Дата и время в Питоне."""

# +
# Модуль datetime
# В базовом функционале Питона нет отдельного типа данных,
# отвечающего за дату и время. Необходимо импортировать модуль,
# который называется datetime.

# для этого вначале импортируем соответствующий класс
from datetime import datetime, timedelta

# Эту же работу мы можем поручить библиотеке Pandas через функцию
# read_csv() и параметр parse_dates.
import pandas as pd
import pytz

# -

# чтобы получить доступ к функции now(), сначала обратимся к модулю,
# потом к классу
print(datetime.now())

# +
# Как вы видите, это не очень удобно. Можно импортировать только класс
# datetime и обращаться непосредственно к нему.


print(datetime.now())
# -

# Объект datetime и функция now()
# поместим созданный с помощью функции now() объект datetime
# в переменную cur_dt
cur_dt = datetime.now()
print(cur_dt)

# +
# с помощью соответствующих атрибутов выведем каждый из
# компонентов объекта

print(
    cur_dt.year,
    cur_dt.month,
    cur_dt.day,
    cur_dt.hour,
    cur_dt.minute,
    cur_dt.second,
    cur_dt.microsecond,
)
# -

# также можно посмотреть на день недели
# метод .weekday() начинает индекс недели с нуля,
# .isoweekday() - с единицы
print(cur_dt.weekday(), cur_dt.isoweekday())

# посмотрим на часовой пояс с помощью атрибута tzinfo
print(cur_dt.tzinfo)

# +
# Для того чтобы добавить такую информацию и вывести,
# например, другой часовой пояс, нам нужно воспользоваться
# модулем pytz.


# выведем текущее время в Москве
dt_moscow = datetime.now(pytz.timezone("Europe/Moscow"))
print(dt_moscow)

# +
# Посмотрим, не появился ли часовой пояс.

print(dt_moscow.tzinfo)

# +
# Timestamp
# компьютеры используют так называемое время Unix, которое
# отсчитывается в секундах c первого января 1970 года.
# Для отображения даты и времени в таком формате в
# Питоне есть объект timestamp (по-английски — «временная отметка»)

# получим timestamp текущего времени с помощью метода .timestamp()
timestamp = datetime.now().timestamp()
print(timestamp)
# -

# Не составляет труда вернуть timestamp обратно в привычный формат.
# для этого воспользуемся методом .fromtimestamp()
print(datetime.fromtimestamp(timestamp))

# +
# Создание объекта datetime вручную
# Дату и время не обязательно получать из функции now().
# Мы вполне можем передать объекту datetime наши собственные
# параметры, например, день рождения Питона.

# передадим объекту datetime 20 февраля 1991 года
hb = datetime(1991, 2, 20)
print(hb)
# -

# извлечем год с помощью атрибута year
print(hb.year)

# создадим timestamp
print(datetime.timestamp(hb))

# Преобразование строки в datetime и наоборот
# дана строка с датой 2 декабря 2007 года и временем
# 12 часов 30 минут и 45 секунд
str_to_dt = "2007-12-02 12:30:45"
type(str_to_dt)

# +
# Преобразуем эту строку в объект datetime с помощью метода .strptime().

res_dt = datetime.strptime(str_to_dt, "%Y-%m-%d %H:%M:%S")

print(res_dt)
print(type(res_dt))
# -

# Datetime в строку через .strftime()
# вначале создадим объект datetime и передадим ему текущую дату
dt_to_str = datetime(2025, 12, 5)
type(dt_to_str)

# +
# преобразуем объект в строку в формате "день недели, месяц число, год"
res_str = datetime.strftime(dt_to_str, "%A, %B %d, %Y")

print(res_str)
print(type(res_str))

# +
# Метод .strftime() можно применять непосредственно к объекту datetime.

dt_to_str.strftime("%A, %B %d, %Y")

# +
# Сравнение и арифметика дат
# Сравнение дат

# Даты можно сравнивать между собой. Для этого
# используются стандартные операторы сравнения >, <, >=, <=, ==, !=.

date1 = datetime(1905, 6, 30)  # "К электродинамике движущихся тел"
date2 = datetime(1916, 5, 11)  # Общая теория относительности

# +
# Вторая дата должна быть «больше», потому что она более поздняя.
# Обратное будет признано ложным.

print(date1 < date2)
print(date1 > date2)

# +
# Календарный и алфавитный порядок дат
# Интересно, что если даты записаны в виде строки в формате
# ГГГГ.ММ.ДД, то в Питоне мы можем их сравнивать, как если
# бы мы сравнивали объекты datetime. Другими словами,
# календарный и алфавитный порядок дат совпадают

# +
# Промежуток времени и класс timedelta

# Если из большей даты вычесть меньшую, то мы получим
# временной промежуток между датами.

delta = date2 - date1
print(delta)

# +
# При этом результат будет храниться в специальном объекте timedelta.

type(delta)

# +
# Атрибут days позволяет посмотреть только дни.

print(delta.days)

# +
# Объект timedelta также можно создать вручную.


# а затем создадим объект timedelta продолжительностью 1 день
timedelta(days=1)
# -

# Арифметика дат
# Объединив объекты datetime и timedelta, мы можем «путешествовать во времени».
# допустим сейчас 1 января 2070 года
future = datetime(2070, 1, 1)
future

# +
# И мы хотим отправиться в 1 января 1900 года, т.е. на 170 лет назад.

# сначала просто умножим 365 дней на 170
time_travel = timedelta(days=365) * 170

# а потом переместимся из будущего в прошлое
past = future - time_travel

# к сожалению, мы немного "не долетим", потому что не
# учли високосные годы, в которых 366 дней
past

# +
# Теперь снова совершим путешествие во времени,
# но на этот раз укажем правильное количество дней.

time_travel = timedelta(days=62092)

past = future - time_travel
past

# +
# Объект timedelta можно также прибавлять к объекту datetime.
# Например, нам может быть нужно создать перечень дат, пусть это будут
# новогодние празники в 2021 году.
# Для этого удобно использовать цикл while.

cur_date = datetime(2021, 1, 1)  # эту дату мы будем выводить
end_date = datetime(2021, 1, 10)  # это граница (условие в цикле while)

# пока верно условие
while cur_date <= end_date:

    # выведем cur_date в формате "месяц число, год"
    print(cur_date.strftime("%b %d, %Y"))

    # прибавим к выводимой дате один день
    cur_date += timedelta(days=1)

# +
# Дата и обработка ошибок
# Конструкция try / except и оператор pass

# Часто мы не уверены, что наш код отработает без ошибок.
# Например, в данных может содержаться неточность,
# о которой мы ничего не знаем.
# При этом нам не хотелось бы, чтобы исполнение кода остановилось.

# Для этого в Питоне есть конструкция try/except.

# +
# пусть дан список чисел в строковом формате,
# и мы хотим посчитать их сумму
# предположим, буква "а" попала в список случайно
numbers = ["5", "10", "a", "15", "10"]

# объявим переменную суммы
total = 0

# пройдемся по числам
for number in numbers:

    # попробуем прибавить число к переменной total
    try:
        total += int(number)

    # если же этого сделать не удастся
    except ValueError:
        # перейдем к следующему числу
        pass

# выведем сумму
total

# +
# Оператор pass просто говорит алгоритму продолжить работу.
# Вместо него можно вывести предупреждение.

total = 0

for number in numbers:
    try:
        total += int(number)
    except ValueError:
        print(f"Элемент '{number}' обработать не удалось")

total
# -

# Обработка нескольких форматов дат
temp: pd.DataFrame = pd.read_csv("temperature.csv")

formats_var: list[str] = ["%Y-%m-%d", "%Y-%m-%-d", "%Y-%m"]

# +
counter: int = 0

for d_var in temp.Date:
    for format_var in formats_var:
        try:
            print(datetime.strptime(d_var, format_var))
            counter += 1
        except ValueError:
            pass

print("Не отобразилось записей:", len(temp) - counter)

# +
# Эту же работу мы можем поручить библиотеке Pandas
# через функцию read_csv() и параметр parse_dates

temp_parsed: pd.DataFrame = pd.read_csv(
    "temperature.csv", index_col="Date", parse_dates=True
)
temp_parsed
