"""Списки, кортежи и множества."""

# # Списки

# +
# Список можно создать (или как правильнее говорить инициализировать)
# через пустые квадратные скобки [] или с помощью функции list()

some_list_1: list[int] = []

print(some_list_1)

# +
# Элементом списка может быть любой объект, например,
# число, строка, список или словарь.

number_three = [3, "число три", ["число", "три"], {"число": 3}]
number_three

# +
# Длину списка можно узнать с помощью функции len().

len(number_three)

# +
# Индекс и срез списка

# у списка есть положительный и отрицательный индексы
abc_list = ["a", "b", "c", "d", "e"]

# воспользуемся ими для вывода первого и последнего элементов
print(abc_list[0], abc_list[-1])

# +
# при работе с вложенным списком
salary_list = [["Анна", 90000], ["Игорь", 85000], ["Алексей", 95000]]

# мы вначале указываем индекс вложенного списка,
# а затем индекс элемента в нем
salary_list[1][0]
# -

# индекс можно узнать с помощью метода .index()
abc_list.index("c")

# +
# метод .index() можно применить и ко вложенному списку

salary_list.index(["Игорь", 85000])

# +
# создадим список с днями недели
days_list = ["Пн", "Вт", "Ср", "Чт", "Пт", "Сб", "Вс"]

# и выведем со второго по пятый элемент
days_list[1:5]
# -

# выведем каждый второй элемент в срезе с первого по пятый
days_list[:5:2]

# проверим есть ли "Пн" в списке
"Пн" in days_list

# # Добавление, замена и удаление элементов списка

# создадим список
numbers = [1, 2, 3, 4, 5]

# добавим один элемент в конец списка с помощью метода .append()
numbers.append(6)
print(numbers)

# добавим элемент в определенное место в списке
# через желаемый индекс этого элемента
numbers.insert(0, 0)
print(numbers)

# изменим четвертый элемент в списке
numbers[3] = 10
print(numbers)

# удалим элемент по его значению
numbers.remove(10)
print(numbers)

# удалим элемент по его индексу через ключевое слово del
del numbers[0]
print(numbers)

# сделаем то же самое с помощью метода .pop()
# этот метод выводит удаляемый элемент
numbers.pop(0)

# Сложение списков
# Добавить к списку еще один список можно с помощью метода .extend()
list_one = [1, 2, 3]
list_two = [4, 5, 6]
list_one.extend(list_two)
print(list_one)

# +
# Кроме того, два списка можно просто сложить (concatenate).

list_three = [7, 8, 9]
combined_list = list_one + list_three
print(combined_list)
# -

# иногда бывает полезно «размножить» элементы списка.
["раз"] * 5

# +
# Такие «произведения» также можно складывать.

["раз"] * 3 + ["два"] * 2
# -

# # Распаковка списков

# заново создадим список с днями недели
# pylint: disable=duplicate-code
week = [
    "Понедельник",
    "Вторник",
    "Среда",
    "Четверг",
    "Пятница",
    "Суббота",
    "Воскресенье",
]

# указав индекс элемента, его можно записать в переменную
monday = week[0]
monday

# +
# срез можно поместить в несколько переменных
monday, tuesday, wednesday = week[:3]

# важно, чтобы количество элементов среза было равно
# количеству переменных
monday, tuesday, wednesday
# -

# можно выделить первый элемент,
# а остальные поместить в переменную со звездочкой
monday, *_ = week
monday

# +
# Аналогичным образом мы можем распаковать
# первый, *остальные и последний элемент списка.

monday, *days, sunday = week
monday, sunday
# -

# # Сортировка списков

# +
# Для сортировки списка можно использовать функцию sorted()
# и метод .sort(). Функция sorted() не изменяет объект
# и сразу выводит результат сортировки.

# отсортируем список по возрастанию
unsorted_list = [5, 2, 9, 1, 5, 6]
sorted(unsorted_list)
# -

# исходный список остается прежним
unsorted_list

# Впрочем, если записать результат вызова функции sorted()
# в переменную, изменение станет постоянным
sorted_list = sorted(unsorted_list)
sorted_list

# метод .sort() сохраняет результат, но не выводит его сразу
# reverse = True задает сортировку по убыванию
unsorted_list.sort(reverse=True)
unsorted_list

# выведем результат
unsorted_list

# метод .reverse() задает обратный порядок,
# сохраняет, но не выводит результат
unsorted_list.reverse()
# выведем результат
unsorted_list

# функция reversed() возвращает итератор
type(reversed(unsorted_list))

# вывести результат можно с помощью функции list()
list(reversed(unsorted_list))

# результат при этом не сохраняется
unsorted_list

# # Преобразование списка в строку

# дан список из строковых элементов
str_list = ["P", "y", "t", "h", "o", "n"]

# с помощью метода .join() можно соединить все элементы
joined_str = "".join(str_list)
joined_str

# если в кавычках ничего не указывать, элементы просто соединятся,
# но можно указать любой другой элемент
joined_str_with_dash = "-".join(str_list)
joined_str_with_dash

# # Арифметика в списках

# дан список чисел
nums_ = [3, 2, 1, 4, 5, 12, 3, 3, 7, 9, 11, 15]

# с помощью метода .count() мы можем посчитать
# частоту вхождения элемента в список
nums_.count(3)

# кроме того мы можем найти минимальное и максимальное значения
# и сумму элементов
result = (min(nums_), max(nums_), sum(nums_))
result

# # List comprehension

# +
# А теперь рассмотрим list comprehension. По сути, list comprehension
# позволяет превратить один список в другой, преобразовывая и отбирая
# элементы исходного списка.
# -

# дан список имен
names = ["Артем", "Антон", "Александр", "Борис", "Виктор", "Геннадий"]

# +
# оставим имена, начинающиеся с буквы "А"

a_names = [name for name in names if name.startswith("А")]
a_names
# -

# переведем все буквы в строчные, условие здесь не нужно
lower_names = [name.lower() for name in names]
lower_names

# схема условия if-else немного отличается
# оставляем имя, если это не Виктор, если Виктор - заменяем на Вадим
replace_name = [name if name != "Виктор" else "Вадим" for name in names]
replace_name

# # Кортежи

# +
# Кортеж (tuple) инициализируется при помощи круглых скобок ()
# или функции tuple().

# создадим две переменные и поместим в них пустые кортежи
tuple_1: tuple[str, ...] = ()
tuple_2: tuple[str, ...] = ()
print(tuple_1, tuple_2)

# +
# Во многом кортеж похож на список.
# Это также упорядоченный набор элементов с индексом,
# начинающимся с нуля.

# создадим кортеж
letters: tuple[str, ...] = ("a", "b", "c")

# и выведем его первый элемент
letters[0]

# +
# но изменить элемент, как мы это делали в списке, нельзя
# letters[0] = 'd'
# -

# для изменения элемента кортеж вначале нужно преобразовать в список
letters_list: list[str] = list(letters)
letters_list[0] = "d"
letters_list

# кортеж из одного элемента можно создать с помощью запятой
single_letter: tuple[str] = ("a",)
type(single_letter)

# если запятую не указывать, получится строка
not_tuple: str = "a"
type(not_tuple)

# # Функция enumerate()

# +
# Если в цикле с функцией enumerate() использовать не две,
# как мы делали раньше, а одну переменную, результатом ее работы
# будет кортеж, состоящий из индекса и соответствующего элемента
# списка.

# создадим список с названием трех компаний
companies = ["Microsoft", "Apple", "Tesla"]

# и в цикле поместим результат работы функции enumerate()
# в одну переменную company
for company_item in enumerate(companies):
    print(company_item)

# +
# Просмотр элементов словаря

# Аналогично, если в цикле for к словарю применить знакомый нам
# метод .items() и использовать только одну переменную,
# мы получим кортежи из ключа и значения.

shopping_dict = {"огурцы": 2, "помидоры": 3, "лук": 1, "картофель": 2}
# -

# то же самое со словарем и методом .items()
for item in shopping_dict.items():
    print(item)

# # Распаковка кортежей

# +
# Распаковать кортеж — значит поместить каждый
# из его элементов в отдельную переменную.

# если в кортеже три элемента, то и переменных должно быть три
letter_a, letter_b, letter_c = ("a", "b", "c")

# выведем переменную letter_a
print(letter_a)

# +
# снова возьмем список компаний
companies = ["Microsoft", "Apple", "Tesla"]

# однако с функцией enumerate() используем две переменные
for index, company in enumerate(companies):
    print(index, company)

# +
# С элементами словаря получается то же самое.

shopping_dict = {"огурцы": 2, "помидоры": 3, "лук": 1, "картофель": 2}

# используем две переменные с методом .items()
for key, value in shopping_dict.items():
    print(key, value)
# -

# # Создание кортежа через функцию zip()

# +
# если есть два и более списка
names = ["Артем", "Антон", "Александр", "Борис", "Виктор", "Геннадий"]
income = [97000, 110000, 95000, 84000, 140000, 120000]

# функция zip() соединит первые элементы списков,
# вторые элементы списков и т.д.
type(zip(names, income))
# -

# для вывода результата нужно передать zip-объект в функцию list()
# на выходе мы получим список из кортежей
list(zip(names, income))

# # Множества

# +
# элементы множества изменять нельзя;
# множество — это набор уникальных элементов, а значит повторы
# в нем удаляются;
# у множества нет индекса, элементы не упорядочены.

# +
# Создание множества
# пустое множество задается через функцию set()
set_1: set[str] = set()

# непустое множество задается через функцию set() и список элементов
set_2: set[str] = {"a", "b", "c"}

# или путем перечисления элементов в фигурных скобках {}
set_3: set[str] = {"a", "b", "c"}

# множество содержит только уникальные элементы,
# поэтому дубликаты удаляются
print(set_1, set_2, set_3)

# +
# создать множество через пустые фигурные скобки нельзя
not_a_set: dict[str, str] = {}

# так создается словарь
type(not_a_set)
# -

# Добавление и удаление элементов
# предположим, что мы хотим создать множество гласных букв
# в русском языке
vowels: set[str] = {"а", "о", "э", "е", "у", "ё", "ю"}

# добавим одну букву "я" методом .add()
vowels.add("я")
vowels

# добавим две буквы "и" и "ы" методом .update()
vowels.update(["и", "ы"])
vowels

# если по ошибке мы добавим согласную букву,
vowels.add("щ")
vowels

# ее можно удалить методом .remove()
vowels.remove("щ")
vowels

# # Теория множеств в Питоне

# два множества равны, если содержат одинаковые элементы,
# при этом порядок элементов не важен
{"a", "b", "c"} == {"c", "b", "a"}

# выведем мощность множества с помощью функции len()
len({"a", "b", "c"})

# проверим, содержится ли элемент во множестве
"a" in {"a", "b", "c"}

# возможна и обратная операция
"a" not in {"a", "b", "c"}

# +
# проверим является ли А подмножеством В
set_a: set[str] = {"a", "b", "c"}
set_b: set[str] = {"a", "b", "c", "d", "e", "f"}

set_a.issubset(set_b)
# -

# проверим является ли B надмножеством А
set_b.issuperset(set_a)

# даны участники команд по обработке естественного языка (nlp)
# и компьютерному зрению (cv)
nlp: set[str] = {"Анна", "Николай", "Павел", "Оксана"}
cv: set[str] = {"Николай", "Евгений", "Ольга", "Оксана"}

# +
# найдем тех, кто работает или в nlp, или в cv, или в обеих командах
print(nlp.union(cv))

# или символ |
print(nlp | cv)

# +
# найдем тех, кто работает и в nlp, и в cv одновременно
print(nlp.intersection(cv))

# или символ &
print(nlp & cv)

# +
# найдем тех, кто работает только в nlp
print(nlp.difference(cv))

# или символ -
print(nlp - cv)
