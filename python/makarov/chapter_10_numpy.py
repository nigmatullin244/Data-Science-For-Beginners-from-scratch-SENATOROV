"""Массив Numpy."""

# # Как создать массив Numpy

# +
# импортируем библиотеку matplotlib
import matplotlib.pyplot as plt

# библиотеку Numpy принято сокращать как np
import numpy as np

# импортируем функцию csr_matrix()
from scipy.sparse import csr_matrix

# -

# Как создать массив Numpy
# Функция np.array()
arr = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
arr

# или кортежа
arr = np.array((0, 1, 2, 3, 4, 5, 6, 7, 8, 9))
arr

# Функция np.arange()
arr = np.arange(10)
arr

# зададим нижнюю и верхнюю границу и шаг
arr = np.arange(2, 10, 2)
print(arr)

# +
# Отличие range() от функции np.arange() заключается в том,
# что первая не допускает использования типа float.

# создадим список с помощью функций range() и list()
# list(range(2, 5.5, 0.5))
# TypeError: 'float' object cannot be interpreted as an integer

# +
# Тип данных элементов массива
# создадим массив с элементами типа float
arr_f = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], float)

print(arr_f)

# тип данных можно посмотреть через атрибут dtype
print(arr_f.dtype)
# -

# # Свойства (атрибуты) массива

# +
# Возьмем массив, который мы создали выше.

arr
# -

# ndim позволяет узнать количество измерений
arr.ndim

# shape выводит количество элементов в каждом измерении
arr.shape

# общее количество элементов во всех измерениях
arr.size

# в нашем случае - это целое число длиной 64 бита
arr.dtype

# # Измерения массива

# +
# Массив с нулевой размерностью

arr_0d = np.array(42)
arr_0d

# +
# выведем измерения, элементы в каждом из них
# и общее количество элементов
print(arr_0d.ndim)
print(arr_0d.shape)
print(arr_0d.size)

# Атрибут shape показывает отсутствие размерности,
# а size указывает на один элемент в массиве.

# +
# Одномерный массив (вектор)

# Вложив несколько массивов с нулевой размерностью
# в квадратные скобки, мы получим одномерный
# массив или вектор.

arr_1d = np.array([1, 2, 3])
arr_1d
# -

# снова воспользуемся атрибутами массива
print(arr_1d.ndim)
print(arr_1d.shape)
print(arr_1d.size)

# +
# Двумерный массив (матрица)

# Поместив во вторые квадратные скобки, например,
# два одномерных массива, мы получим двумерный
# массив или матрицу.

# с точки зрения синтаксиса - это просто вложенные списки
arr_2d = np.array([[1, 2, 3], [4, 5, 6]])
arr_2d

# +
# Посмотрим на свойства.

print(arr_2d.ndim)
print(arr_2d.shape)
print(arr_2d.size)

# +
# точки зрения Numpy матрица с одной строкой
# или одним столбцом — это разные объекты.
# Начнем с матрицы, которая имеет три
# вектора по одному элементу.

column = np.array([[1], [2], [3]])
print(column)
# посмотрим на размерность
print(column.shape)

# +
# Теперь наоборот, создадим матрицу с одной строкой,
# в которой три элемента.

row = np.array([[1, 2, 3]])
print(row)
# размерность будет иной
row.shape

# +
# Трехмерный массив

# При этом, вместо того чтобы вручную прописывать все 12 значений,
# мы последовательно воспользуемся функцией
# np.arange() и методом np.reshape().
# np.reshape() распределит элементы по измерениям

arr_3d = np.arange(12).reshape(2, 2, 3)
arr_3d

# +
# выведем атрибуты
print(arr_3d.ndim)
print(arr_3d.shape)
print(arr_3d.size)

# атрибут shape сначала выводит размерность внешнего измерения,
# в нем две матрицы. Далее в каждую матрицу вложены
# два одномерных вектора. В каждом векторе по три элемента.
# -

# # Другие способы создания массива

# Массив из нулей
# функция np.zeros()
# ей мы можем передать одно значение
# для создания одномерного массива,
# заполненного нулями
np.zeros(5)

# или кортеж из чисел для указания количества
# нулей в каждом измерении
np.zeros((2, 3))

# +
# Массив из единиц
# Функция np.ones()

# создадим трехмерный массив
np.ones((2, 2, 3))

# +
# Массив, заполненный заданным значением

# создадим матрицу 2 х 3 и заполним ее цифрой четыре
np.full((2, 3), 4)

# +
# Пустой массив Numpy
# функция np.empty() возвращает массив заданной размерности,
# но без инициализации его значений

# создадим пустую матрицу 3 х 2
np.empty((3, 2))

# +
# Функции np.zeros_like(), np.ones_like(),
# np.full_like(), np.empty_like()

# создадим массив 2 x 3 с числами от 1 до 6
a_var = np.arange(1, 7).reshape(2, 3)
a_var
# -

# превратим его в массив с нулями
np.zeros_like(a_var)

# единицами
np.ones_like(a_var)

# двойками
np.full_like(a_var, 2)

# и пустыми значениями
np.empty_like(a_var)

# # Функция np.linspace()

# +
# Функция np.linspace() позволяет указать диапазон начального
# и конечного значений, а также количество равноудаленных
# точек внутри этого диапазона (включая начальное и конечное значения).

# создадим диапазон от 0 до 0,9 и
# разделим его на десять точек, включая 0 и 0,9
np.linspace(0, 0.9, 10)
# -

# с функцией np.arange мы точно знаем, где будут расположены точки
np.arange(0, 1, 0.1)

# +
# Функцию np.linspace() удобно использовать
# для построения графиков функций.


# зададим размер графика в дюймах
plt.figure(figsize=(8, 6))

# зададим интервал, например, от -5 до 5 и
# сформируем на нем 5000 точек
# это будут наши координаты по оси x
x_var = np.linspace(-5, 5, 5000)

# по оси y отложим квадрат этих точек
y_var = x_var**2

# создадим сетку
plt.grid()

# выведем кривую и подписи на графике
plt.plot(x_var, y_var)
plt.xlabel("x", fontsize=14)
plt.ylabel("y", fontsize=14)

# результатом будет парабола
plt.show()
# -

# в качестве примера выведем первые десять точек,
# созданные функцией np.linspace()
x_var[:10]

# # Функции np.random.rand() и np.random.randint()

# +
# Массивы можно также создавать с помощью функций,
# генерирующих псевдослучайные числа. В частности,
# функция np.random.rand() создает массив заданной
# размерности, заполненный числами от 0 до 1
# (единица в диапазон не входит).

# создадим массив заданной размерности, заполненный числами
# в интервале [0, 1)
np.random.rand(4, 3)

# +
# создадим массив целых чисел в заданном диапазоне
# (верхняя граница в него не входит)
# и с заданной размерностью

np.random.randint(-3, 3, size=(2, 3, 2))
# -

# # Создание массива из функции

# +
# Помимо вышеупомянутых способов массив можно
# создавать с помощью собственных функций.


# создадим собственную функцию, которая принимает два числа
# и возводит первое число в степень второго
def power(i_var: int | float, j_var: int | float) -> int | float:
    """Возводит число в степень.

    Args:
        i_var: Основание
        j_var: Показатель степени

    Returns:
        Результат i в степени j
    """
    return pow(i_var, j_var)


# -

# применим эту функцию к каждой ячейке массива 3 x 3
np.fromfunction(power, (3, 3))

# также можно передать lambda-функцию, которая
# проверяет равенство двух чисел
np.fromfunction(lambda i_var, j_var: i_var == j_var, (3, 3))

# # Матрица csr и метод .toarray()

# +
# Кроме этого в случае если данные хранятся в
# формате csr (сжатое хранения строкой,
# compressed sparse row), то мы можем
# преобразовать их обратно в массив Numpy с помощью метода .toarray().

# создадим матрицу с преобладанием нулевых значений
null_arr = np.array(
    [[2, 0, 0, 1, 0, 0, 0], [0, 0, 3, 0, 0, 2, 0], [0, 0, 0, 1, 0, 0, 0]]
)
null_arr
# -

# посчитаем долю нулевых значений
null_frac = 1.0 - np.count_nonzero(null_arr) / null_arr.size
print(null_frac)

# +
# !{sys.executable} -m pip install scipy
# Преобразуем матрицу в формат csr.


# матрицу A удобно хранить в формате csr,
csr_arr = csr_matrix(null_arr)

# где указывается положение ненулевого значения и само значение
print(csr_arr)
# -

# восстановить массив Numpy можно с помощью метода .toarray()
rest_arr = csr_arr.toarray()
rest_arr

# # Индексы и срезы

# индексы
# рассмотрим двумерный массив
a_2d = np.array([[1, 2, 3], [4, 5, 6]])
a_2d

# первое значение атрибута shape относится к
# внешнему измерению
# второе - к внутреннему
a_2d.shape

# выведем первый элемент внешнего измерения
a_2d[0]

# второй индекс [0] позволяет обратиться
# к элементам внутреннего измерения
a_2d[0][0]

# выведем значение шесть
a_2d[1][2]

# Срез массива
# начнем с одномерного массива
b_slice = np.array([1, 2, 3, 4, 5, 6, 7, 8])
b_slice

# возьмем каждый второй элемент
# в интервале с 1-го по 6-й индекс
b_slice[1:6:2]

# теперь возьмем двумерный массив
c_2d = np.array([[1, 2, 3, 4], [5, 6, 7, 8]])
c_2d

# сделаем срез из первой строки и первых двух столбцов
c_2d[0, :2]

# а теперь возьмем обе строки во втором столбце
c_2d[:, 1]

# выведем элемент в первой строке и первом столбце
c_2d[0, 0]

# выведем элемент в последней строке и последнем столбце
c_2d[-1, -1]

# возьмем всю вторую строку и каждый второй столбец
c_2d[1, ::2]

# Массив 3D
# создадим трехмерный массив
d_3d = np.arange(16).reshape(4, 2, -1)
d_3d

# выведем значение 10
d_3d[2][1][0]

# выведем третью и четвертую матрицу [2:]
# и в них вторую строку [1] и все столбцы [:]
d_3d[2:, 1, :]

# выведем первые две матрицы массива
d_3d[:2]

# выведем первые строки каждой матрицы
d_3d[:, 0, :]

# +
# Оси массива
# Массив 2D

# обратимся к двумерному массиву
arr_2d_axis = np.array([[1, 2], [3, 4]])
arr_2d_axis
# -

arr_2d_axis.shape

# найдем сумму по столбцам (вдоль оси 0)
np.sum(arr_2d_axis, axis=0)

# и сумму по строкам (вдоль оси 1)
np.sum(arr_2d_axis, axis=1)

# если передать кортеж с указанием обеих осей (0, 1)
# сумма будет рассчитана вначале вдоль оси 0, затем вдоль оси 1
np.sum(arr_2d_axis, axis=(0, 1))

# если ничего не указывать, сумма также будет
# рассчитана по всем элементам массива
np.sum(arr_2d_axis)

# в этом случае под капотом стоит значение по
# умолчанию axis = None
np.sum(arr_2d_axis, axis=None)

# axis = -1 соответствует последней оси массива,
# в данном случае, axis = 1
np.sum(arr_2d_axis, axis=-1)

# axis = -2 указывает на первую ось, то есть axis = 0
np.sum(arr_2d_axis, axis=-2)

# Массив 3D
# обратимся к трехмерному массиву
arr_3d_axis = np.arange(12).reshape(2, 2, 3)
arr_3d_axis

# применим np.sum() с параметром axis = 0
np.sum(arr_3d_axis, axis=0)

# теперь возьмем первую матрицу
arr_3d_axis[0]

# возьмем вторую матрицу
arr_3d_axis[1]

# и поэлементно сложим их
arr_3d_axis[0] + arr_3d_axis[1]

# Сложение вдоль второй оси (axis = 1)
# применим np.sum()
np.sum(arr_3d_axis, axis=1)

# сложим столбцы первой
arr_3d_axis[0][0] + arr_3d_axis[0][1]

# и второй матрицы
arr_3d_axis[1][0] + arr_3d_axis[1][1]

# Сложение вдоль третьей оси (axis = 2)
# применим np.sum()
np.sum(arr_3d_axis, axis=2)

# сложим элементы первой строки первой матрицы
arr_3d_axis[0][0][0] + arr_3d_axis[0][0][1] + arr_3d_axis[0][0][2]

# второй строки первой матрицы
arr_3d_axis[0][1][0] + arr_3d_axis[0][1][1] + arr_3d_axis[0][1][2]

# первой строки второй матрицы
arr_3d_axis[1][0][0] + arr_3d_axis[1][0][1] + arr_3d_axis[1][0][2]

# второй строки второй матрицы
arr_3d_axis[1][1][0] + arr_3d_axis[1][1][1] + arr_3d_axis[1][1][2]

# Сложение вдоль первой и второй осей (axis = (0, 1))
# применим функцию np.sum()
np.sum(arr_3d_axis, axis=(0, 1))

# Сложение вдоль всех трех осей (axis = (0, 1, 2))
np.sum(arr_3d_axis, axis=(0, 1, 2))

# # Операции с массивами

# Вновь возьмем трехмерный массив.
# Функция len()
arr_3d_axis = np.arange(12).reshape(2, 2, 3)
arr_3d_axis

len(arr_3d_axis)

# чтобы вывести длину внутреннего измерения,
# т.е. вектора из трех элементов,
# нужно воспользоваться индексами
len(arr_3d_axis[0][0])

# Вхождение элемента в массив
# проверим, входит ли значение 3 в массив arr_3D
3 in arr_3d_axis

# проверим, не входит ли значение 11 в массив arr_3D
11 not in arr_3d_axis

# # Распакова массива

# возьмем матрицу из трех строк и девяти столбцов
a_unpack = np.arange(1, 28).reshape(3, 9)
a_unpack

# +
# каждую строку можно распаковать в отдельную переменную
x_unp, y_unp, z_unp = a_unpack

# выведем первую переменную (строку)
x_unp

# +
# теперь распакуем первый, последний и остальные элементы
# первой строки в отдельные переменные
x_sep, *y_sep, z_sep = a_unpack[0]

# выведем каждую переменную
print(x_sep)
print(y_sep)
print(z_sep)
# -

# # Изменение элементов массива

# обратимся к двумерному массиву
arr_2d_index = np.array([[1, 2, 3], [4, 5, 6]])
arr_2d_index

# заменим первый элемент первой строки по его индексу
arr_2d_index[0, 0] = 2
arr_2d_index

# запишем значение 1 в первую строку
arr_2d_index[0] = 1
arr_2d_index

# запишем 0 в третий столбец массива
arr_2d_index[:, 2] = 0
arr_2d_index

# обратимся к трехмерному массиву
arr_3d_index = np.arange(12).reshape(2, 2, 3)
arr_3d_index

# +
# выберем второй столбец второй матрицы и
# заменим значения столбца 7 и 10 на 0 и 1
arr_3d_index[1, :, 1] = [0, 1]

# при такой операции размер среза должен совпадать
# с количеством передаваемых значений
arr_3d_index
# -

# заменим все элементы массива на число семь
arr_3d_index.fill(7)
arr_3d_index

# # Сортировка массива и обратный порядок его элементов

# Функция np.sort()
# возьмем двумерный массив
a_sort = np.array([[4, 8, 2], [2, 3, 1]])
a_sort

# по умолчанию сортировка идет с параметром axis = -1 (последняя ось)
np.sort(a_sort)

# для двумерного массива это ось 1
np.sort(a_sort, axis=1)

# посмотрим на сортировку по оси 0
np.sort(a_sort, axis=0)

# axis = None вначале возвращает одномерный массив,
# а затем сортирует
np.sort(a_sort, axis=None)

# # Обратный порядок элементов массива через оператор среза

# оператор среза с параметром шага -1
# задает обратный порядок элементов массива
reverse_arr = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])[::-1]
print(reverse_arr)

# обратный порядок можно совмещать со срезами
reverse_arr_slice = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])[-3:3:-1]
print(reverse_arr_slice)

# в двумерном массиве
a_rev = np.array([[4, 8, 2], [2, 3, 1], [1, 7, 2]])
a_rev

# можно задать обратный порядок по двум измерениям (axis = (0, 1))
a_rev[::-1, ::-1]

# обратный порядок по внешнему (axis = 0)
a_rev[::-1]

# и внутреннему измерению (axis = 1)
a_rev[:, ::-1]

# +
# Обратный порядок через функцию np.flip()

# по умолчанию, задает обратный порядок по двум измерениям
# то же самое, что axis = (0, 1)
np.flip(a_rev)
# -

# можно также задать обратный порядок по внешнему
np.flip(a_rev, axis=0)

# и внутреннему измерениям
np.flip(a_rev, axis=1)

# для сортировки массива в убывающем порядке
a_rev = np.array([4, 2, 6, 1, 7, 3, 5])

# мы можем последовательно применить np.sort() и оператор среза
sorted_desc = np.sort(a_rev)[::-1]
print(sorted_desc)

# исходный массив не изменился
a_rev

# можно и обратном порядке, но уже с методом .sort()
a_rev[::-1].sort()

# изменение стало постоянным
a_rev

# Изменение размерности
# возьмем простой трехмерный массив
arr_3d_index = np.arange(12).reshape(2, 2, 3)
arr_3d_index

# в нем 12 элементов
arr_3d_index.size

# поменяем размерность при сохранении общего количества элементов
arr_2d_index = arr_3d_index.reshape(2, 6)
arr_2d_index

# функция np.resize() позволяет не сохранять
# прежнее количество элементов
# существующие элементы копируются в новые ячейки
np.resize(arr_2d_index, (3, 6))

# arr_2D ссылается на другой массив, поэтому
# сначала нужно сделать его копию
arr_2d_copy = arr_2d_index.copy()

# метод .resize() сделает копию, изменит размерность
# и заполнит пропуски нулями
arr_2d_copy.resize(4, 6)
arr_2d_copy

# .flatten() переводит ("вытягивает") массив в одно измерение и
# создает копию исходного массива (как метод .copy())
arr_3d_index.flatten()

# .ravel() делает то же самое,
# но не создает копию исходного массива и поэтому быстрее чем .flatten()
arr_3d_index.ravel()

# np.newaxis добавляет измерение в массиве
a_newaxis = np.array([1, 2, 3])
a_newaxis.shape

# +
# добавим первое измерение
b_newaxis = a_newaxis[np.newaxis, :]

print(b_newaxis)
print(b_newaxis.shape)

# +
# добавим второе измерение
c_two_newaxis = a_newaxis[:, np.newaxis]

print(c_two_newaxis)
print(c_two_newaxis.shape)
# -

# Функция np.expand_dims()
# возьмем двумерный массив
a_expand = np.array([[1, 2], [3, 4]])
a_expand

# добавим внешнее измерение
np.expand_dims(a_expand, axis=0)

# добавим измерение "по середине"
np.expand_dims(a_expand, axis=1)

# возьмем массив 4D
# первое и последнее измерения содержат по одному элементу
arr_4d_resize = np.arange(9).reshape(1, 3, 3, 1)
arr_4d_resize

# удалим эти измерения с помощью функции np.squeeze()
np.squeeze(arr_4d_resize)

# +
# новый массив имеет только два измерения
arr_squeeze = np.squeeze(arr_4d_resize).shape

print(arr_squeeze)
# -

# # Объединение массивов

# создадим два квадратных массива
a_sq = np.arange(4).reshape(2, 2)
a_sq

b_sq = np.arange(4, 8).reshape(2, 2)
b_sq

# объединим два массива вдоль оси 0 без
# (!) добавления нового измерения
np.concatenate((a_sq, b_sq), axis=0)

# то же самое вдоль оси 1
np.concatenate((a_sq, b_sq), axis=1)

# Функция np.stack()
# здесь отличие в том, что мы добавляем новую ось (измерение)
np.stack((a_sq, b_sq), axis=0)

# при axis = 1 мы объединяем первые и вторые строки двух массивов
np.stack((a_sq, b_sq), axis=1)

# при axis = 2 объединяются элементы с одинаковыми индексами
np.stack((a_sq, b_sq), axis=2)
