"""ООП_Молчанов."""

# +
# Объекты и классы


class Person:
    """Базовый класс Person с атрибутом имени."""

    name = "Ivan"


# -

Person.name

# +
# Атрибуты класса

Person.__name__

# название класса

# +
# Методы класса

dir(Person)

# +
# Тип класса

Person.__class__

# +
# Вызов класса возвращает его объект

person = Person()
# -

person.__class__

person.__class__.__name__

# +
# класс как объект

type(person)

# +
new_person = type(person)()

new_person

# Новый экземпляр класса Person

# +
# сравним id person и new_person
person_ids = (id(person), id(new_person))
person_ids

# Класс - описание объекта

# +
# Свойства и функции классов
# Класс создает свой пространство имен
# Имена переменных - функции и значения, которые принадлежат классу


class PersonV2:
    """Класс Person с атрибутом имени."""

    name = "Ivan"


# Переменные должны быть объявлены внутри класса
# -

# Пространство имен класса
PersonV2.__dict__

# +
# добавим новое свойство классу

PersonV2.age = 30  # type: ignore[attr-defined]
# -

PersonV2.__dict__

# +
# Свойства классов можно назначать через специальные функции

getattr(PersonV2, "name")
# -

setattr(PersonV2, "dob", 1990)

delattr(PersonV2, "dob")

PersonV2.__dict__

# +
# Объявление функции класса


class PersonV3:
    """Класс Person с методом приветствия."""

    name = "Ivan"

    def greet(self) -> str:
        """Greet по имени класса."""
        return f"Hello, {self.__class__.name}!"


# -

person_v3 = PersonV3()
person_v3.greet()

# +
# Классы вызываемые объекты


class PersonV4:
    """Базовый класс Person."""

    name = "Ivan"


print(PersonV4.__dict__)

# +
# Создание экземпляра класса

p1 = PersonV4()
# -

p1

p2 = PersonV4()

# Сравним id p1 и p2
person_ids_v4 = (id(p1), id(p2))
person_ids_v4

# +
# Создаем экземпляры класса, чтобы хранить разные
# значения одних и тех же свойств

print(p1.name)
print(p2.name)
# -

# Свойство name ссылается на одно и то же значение в памяти
print(id(p1.name))
print(id(p2.name))
print(id(PersonV4.name))

# Обратимся к содержанию словарей у экземпляров класса
print(p1.__dict__)
print(p2.__dict__)
# Они пусты, так как мы не присваивали значения свойствам
# экземпляров класса. Python ищет свойства сначала в экземпляре
# класса, если не находит, то идет в класс и ищет там

# +
# Свойства класса создают поведение и состояние объектов по
# Для этого нужно создавать экземпляры класса, чтобы хранить
# свое уникальное состояние

p1.name = "Oleg"
p2.name = "Dima"

# pylint: disable=attribute-defined-outside-init
p2.age = 25  # type: ignore[attr-defined]
# -

print(p1.__dict__)
print(p2.__dict__)

person_names_ages = (p1.name, p2.name, p2.age)  # type: ignore[attr-defined]
person_names_ages

PersonV4.__dict__

# +
# p1.age # AttributeError: 'PersonV4' object has no attribute
# 'age' и в родительском классе не нашел
# -

# Добавление или изменение свойств класса влияет на его
# экземпляры
person_a = PersonV4()
person_b = PersonV4()
PersonV4.name = "Sergey"
names = (person_a.name, person_b.name)
names
# Мы переопределили свойство name класса PersonV4,
# и оба экземпляра класса получили новое значение по умолчанию

# +
# классы являются вызываемыми объектами, и при вызове
# классов мы получаем его экземпляр,
# у каждого экземпляра и класса есть свое пространство имен
# которые не связанны между собой
# Эта особенность позволяет создавать объекты с одинаковым
# поведением, но с разным состоянием


# +
# Функции классов и методы экземпляров классов
class PersonV5:
    """Класс Person с методом приветствия."""

    def hello(self) -> None:
        """Выводит приветствие."""
        print("hello")


PersonV5.hello
# Объект функции класса PersonV5
# -

# Создадим экземпляр класса и посмотрим на объект функции
# без вызова
person_v5 = PersonV5()
person_v5.hello
# bound method и указание на экземпляр класса person_v5
# аттрибут hello переменной person_v5 является связанным методом
# с объектом hello класса PersonV5

PersonV5.hello(person_v5)

# +
# person_v5.hello() работает благодаря связыванию метода
# TypeError: PersonV5.hello() takes 1 positional argument
# but 2 were given
# -

# Посмотрим на типы объекта hello у класса и экземпляра
types_info = (type(PersonV5.hello), type(person_v5.hello))
types_info
# Функции и методы разные классы
# Функции класса при создании экземпляра класса
# превращаются в методы экземпляра и связываются с этим
# экземпляром

# посмотрим на id объектов
ids_info = (id(PersonV5.hello), id(person_v5.hello))
ids_info

# у них разные атрибуты
dir_info = (dir(PersonV5.hello), dir(person_v5.hello))
dir_info

# сперва питон ищет определение имени в локальном пространстве
# имен экземпляра класса
person_v5.__dict__

PersonV5.hello(person_v5)
# Вызов функции класса через экземпляр класса

# +
# методы или функции нужны для обработки значений,
# которые были сохранены в объекте - экземпляре класса,
# а их пространства имен изолированны друг от друга

# +
# Раз мы вызываем функцию определенную в классе
# чтобы эта функция работала как нам нужно,
# мы должны передать ей экземпляр класса
# в пространстве имен которого сохранено нужное значение
# Класс может работать со значением экземпляра класса,
# только получив экземпляр этого класса и обратившись к его
# свойствам. Для этого python связывает с методом экземпляра
# сам экземпляр чтобы класс мог обратиться к своему экземпляру
# и получить доступ к пространству имен (свойствам)

# +
# под капотом python вызывает функцию
# PersonV5.hello(person_v5)

# +
# Методы это классы-обертки, которые объединяют функции
# класса и конкретные экземпляры класса
# -

hex_ids = (
    hex(id(person_v5)),
    hex(id(person_v5.hello.__self__)),  # type: ignore[attr-defined]
)
hex_ids
# это тот же самый объект экземпляра класса person_v5

# +
# свойстве self была сохранена ссылка на экземпляр класса
# -

# свойстве func сохранены ссылка на функцию hello
person_v5.hello.__func__ is PersonV5.hello  # type: ignore[attr-defined]

# +
# при вызове метода из экземпляра класса туда будет
# передаваться сам экземпляр класса


class PersonV6:
    """Класс Person для демонстрации параметра self."""

    def hello(self) -> None:
        """Выводит информацию об объекте."""
        print(self)


# -

# создаем экземпляр класса
person_v6 = PersonV6()
person_v6.hello()

hex(id(person_v6))

# +
# первый параметр методов экземпляра класса - self


class PersonV7:
    """Класс Person с методом приветствия."""

    def hello(self) -> None:
        """Выводит объект."""
        print(self)


# это только функция которая учитывает, что ее будут вызывать
# из экземпляра. Методом эта функция станет тогда, когда
# будет создан экземпляр класса и эта функция будет
# связанна с этим экземпляром класса, то есть получит
# ссылку на этот экземпляр

# +
# инициализация экземпляров


class PersonV8:
    """Класс Person с методами создания и отображения."""

    def __init__(self) -> None:
        """Инициализация."""
        self.name: str | None = None  # Инициализация

    def create(self) -> None:
        """Создает атрибут name."""
        self.name = "Ivan"

    def display(self) -> None:
        """Выводит имя."""
        print(self.name)


# self.name = 'Ivan' это тоже самое,
# что person = PersonV8() person.name = 'Ivan'
# -

person_v8 = PersonV8()

# +
# person_v8.display() # AttributeError: 'PersonV8' object
# has no attribute 'name' потому что локальный словарь dict
# пустой и имя name в родительском класса не определенно
# нужно сначала вызвать метод create чтобы создать
# экземпляру новое свойство

person_v8.create()
person_v8.display()

# +
# для задания свойств экземплярам класса при создании
# и для присваивания из первоначальных значений
# то есть для их инициализации есть метод __init__
# который python вызывает автоматическии при вызове класса,
# то есть при создании экземпляра


class PersonV9:
    """Класс Person с инициализацией."""

    def __init__(self, name: str) -> None:
        """Инициализирует имя."""
        self.name = name

    def display(self) -> None:
        """Выводит имя."""
        print(self.name)


# -

# создадим экземпляр
person_v9 = PersonV9("ivan")

person_v9.name

person_v9.__dict__

# +
# когда создается экземпляр класса
# питон сначала вызывает метод __new__()
# который создает сам экземпляр
# __init__ инициализирует экземпляр свойствами и их значениями
# делает присвоение на лету, после создания класса
